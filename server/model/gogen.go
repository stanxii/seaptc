//+build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"io/ioutil"
	"log"
	"os"
	"reflect"
	"sort"
	"strings"
	"text/template"
)

type fieldInfo struct {
	Go    string
	Store string
	Type  string
}

var equalExceptions = map[string]string{
	"[]int":    "equalIntSlice(x.%s, y.%s)",
	"[]string": "equalStringSlice(x.%s, y.%s)",
}

func (f *fieldInfo) Equal() string {
	eq, ok := equalExceptions[f.Type]
	if !ok {
		eq = "x.%s == y.%s"
	}
	return fmt.Sprintf(eq, f.Go, f.Go)
}

type typeInfo struct {
	Name      string
	FieldSets map[string][]*fieldInfo
	Fields    []*fieldInfo
}

func sortNames(names []*fieldInfo) {
	sort.Slice(names, func(i, j int) bool { return names[i].Go < names[j].Go })
}

func findStruct(f *ast.File, typeName string) *ast.StructType {
	for _, n := range f.Decls {
		n, ok := n.(*ast.GenDecl)
		if !ok {
			continue
		}
		if n.Tok != token.TYPE {
			continue
		}
		for _, n := range n.Specs {
			n := n.(*ast.TypeSpec)
			if n.Name.Name == typeName {
				n, _ := n.Type.(*ast.StructType)
				return n
			}
		}
	}
	return nil
}

var codeTemplate = template.Must(template.New("").Parse(`
// Code generated by gogen.go; DO NOT EDIT.

package model

{{range $type := .}}
const (
    {{range $type.Fields -}}
    {{$type.Name}}_{{.Go}} = {{printf "%q" .Store}}
    {{end}}
)
{{end}}

{{range $type := .}}{{range $name, $fields := $type.FieldSets -}}
    func (x *{{$type.Name}}) Copy{{$name}}Fields(y *{{$type.Name}}) {
        {{range $fields -}}
            x.{{.Go}} = y.{{.Go}}
        {{end -}}
    }

    func (x *{{$type.Name}}) Equal{{$name}}Fields(y *{{$type.Name}}) bool {
        return {{range $i, $f := $fields -}}{{if $i}} &&
        {{end}}{{$f.Equal}}{{end}}
    }

{{end}}{{end}}
`))

func main() {
	log.SetFlags(0)
	output := flag.String("output", "", "Write output to `file`")
	input := flag.String("input", "", "Read from `file`")
	flag.Parse()

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, *input, nil, 0)
	if err != nil {
		log.Fatal(err)
	}

	var tis []*typeInfo
	for _, typeName := range flag.Args() {
		st := findStruct(file, typeName)
		if st == nil {
			log.Fatalf("%s: could not find struct type %s", *input, typeName)
		}

		ti := typeInfo{
			Name:      typeName,
			FieldSets: make(map[string][]*fieldInfo),
		}

		for _, f := range st.Fields.List {
			for _, name := range f.Names {
				if !ast.IsExported(name.Name) {
					continue
				}
				if f.Tag == nil {
					log.Fatalf("%s: missing field tag %s.%s", *input, typeName, name.Name)
				}
				tag := reflect.StructTag(f.Tag.Value)
				storeName := strings.Split(tag.Get("datastore"), ",")[0]
				if storeName == "" {
					log.Fatalf("%s: missing datastore name for %s.%s", *input, typeName, name.Name)
				}

				var buf bytes.Buffer
				printer.Fprint(&buf, fset, f.Type)

				field := &fieldInfo{Go: name.Name, Store: storeName, Type: buf.String()}
				ti.Fields = append(ti.Fields, field)
				if tag := tag.Get("fields"); tag != "" {
					for _, set := range strings.Split(tag, ",") {
						ti.FieldSets[set] = append(ti.FieldSets[set], field)
					}
				}
			}
		}

		sortNames(ti.Fields)
		for _, names := range ti.FieldSets {
			sortNames(names)
		}
		tis = append(tis, &ti)
	}

	var buf bytes.Buffer
	if err := codeTemplate.Execute(&buf, tis); err != nil {
		log.Fatal(err)
	}
	code, err := format.Source(buf.Bytes())
	if err != nil {
		for i, p := range bytes.Split(buf.Bytes(), []byte("\n")) {
			fmt.Fprintf(os.Stderr, "%d: %s\n", i+1, p)
		}
		log.Fatalf("error formating source: %v", err)
	}

	if *output != "" {
		err = ioutil.WriteFile(*output, code, 0666)
		if err != nil {
			log.Fatal(err)
		}
		return
	}

	os.Stdout.Write(code)
}
