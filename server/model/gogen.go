//+build ignore

package main

import (
	"bytes"
	"crypto/md5"
	"encoding/hex"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/printer"
	"go/token"
	"io"
	"io/ioutil"
	"log"
	"os"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"text/template"
)

type fieldInfo struct {
	Go    string
	Store string
	Type  string
}

var equalExceptions = map[string]string{
	"[]int":             "equalIntSlice(x.%s, y.%s)",
	"[]string":          "equalStringSlice(x.%s, y.%s)",
	"[]InstructorClass": "equalInstructorClassSlice(x.%s, y.%s)",
}

func (f *fieldInfo) Equal() string {
	eq, ok := equalExceptions[f.Type]
	if !ok {
		eq = "x.%s == y.%s"
	}
	return fmt.Sprintf(eq, f.Go, f.Go)
}

type fieldSet struct {
	Fields []*fieldInfo
}

func (fs fieldSet) NamesHash() string {
	h := md5.New()
	for _, f := range fs.Fields {
		io.WriteString(h, f.Go)
	}
	sum := h.Sum(nil)
	return hex.EncodeToString(sum[:])
}

type typeInfo struct {
	Name      string
	FieldSets map[string]fieldSet
	Fields    []*fieldInfo
}

func sortNames(names []*fieldInfo) {
	sort.Slice(names, func(i, j int) bool { return names[i].Go < names[j].Go })
}

func findStruct(f *ast.File, typeName string) *ast.StructType {
	for _, n := range f.Decls {
		n, ok := n.(*ast.GenDecl)
		if !ok {
			continue
		}
		if n.Tok != token.TYPE {
			continue
		}
		for _, n := range n.Specs {
			n := n.(*ast.TypeSpec)
			if n.Name.Name == typeName {
				n, _ := n.Type.(*ast.StructType)
				return n
			}
		}
	}
	return nil
}

var codeTemplate = template.Must(template.New("").Parse(`
// Code generated by gogen.go; DO NOT EDIT.

package model

{{with .Imports}}
import (
    {{- range $k, $v := .}}
    {{printf "%q" $k}}
    {{- end}}
)
{{end}}

{{range $type := .Types}}
const (
    {{range $type.Fields -}}
    {{$type.Name}}_{{.Go}} = {{printf "%q" .Store}}
    {{end}}
)
{{end}}

{{range $type := .Types}}{{range $name, $fieldSet := $type.FieldSets -}}
    func (x *{{$type.Name}}) Copy{{$name}}FieldsTo(y *{{$type.Name}}) {
        {{range $fieldSet.Fields -}}
            y.{{.Go}} = x.{{.Go}}
        {{end -}}
    }

    func (x *{{$type.Name}}) Equal{{$name}}Fields(y *{{$type.Name}}) bool {
        return {{range $i, $f := $fieldSet.Fields -}}{{if $i}} &&
        {{end}}{{$f.Equal}}{{end}}
    }

    func (x *{{$type.Name}}) Hash{{$name}}Fields() string {
        h := md5.New()
        hashValue(h, {{printf "%q" $fieldSet.NamesHash}})
        {{range $fieldSet.Fields -}}
            hashValue(h, x.{{.Go}})
        {{end -}}
        sum := h.Sum(nil)
        return hex.EncodeToString(sum[:])
    }

{{end}}{{end}}
`))

func main() {
	log.SetFlags(0)
	output := flag.String("output", "", "Write output to `file`")
	input := flag.String("input", "", "Read from `file`")
	flag.Parse()

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, *input, nil, 0)
	if err != nil {
		log.Fatal(err)
	}

	var tis []*typeInfo
	for _, typeName := range flag.Args() {
		st := findStruct(file, typeName)
		if st == nil {
			log.Fatalf("%s: could not find struct type %s", *input, typeName)
		}

		ti := typeInfo{
			Name:      typeName,
			FieldSets: make(map[string]fieldSet),
		}

		for _, f := range st.Fields.List {
			for _, name := range f.Names {
				if !ast.IsExported(name.Name) {
					continue
				}
				if f.Tag == nil {
					log.Fatalf("%s: missing field tag %s.%s", *input, typeName, name.Name)
				}
				unquoted, err := strconv.Unquote(f.Tag.Value)
				if err != nil {
					log.Fatalf("%s: error parsing field tag %s.%s: %v", *input, typeName, name.Name, err)
				}
				tag := reflect.StructTag(unquoted)
				storeName := strings.Split(tag.Get("datastore"), ",")[0]
				if storeName == "" {
					log.Fatalf("%s: missing datastore name for %s.%s", *input, typeName, name.Name)
				}

				var buf bytes.Buffer
				printer.Fprint(&buf, fset, f.Type)

				field := &fieldInfo{Go: name.Name, Store: storeName, Type: buf.String()}
				if field.Store != "-" && field.Store != "" {
					ti.Fields = append(ti.Fields, field)
				}
				if tag := tag.Get("fields"); tag != "" {
					for _, set := range strings.Split(tag, ",") {
						fs := ti.FieldSets[set]
						fs.Fields = append(fs.Fields, field)
						ti.FieldSets[set] = fs
					}
				}
			}
		}

		sortNames(ti.Fields)
		for _, fs := range ti.FieldSets {
			sortNames(fs.Fields)
		}
		tis = append(tis, &ti)
	}

	imports := map[string]bool{}
	for _, ti := range tis {
		if len(ti.FieldSets) > 0 {
			imports["crypto/md5"] = true
			imports["encoding/hex"] = true
			break
		}
	}

	data := struct {
		Types   []*typeInfo
		Imports map[string]bool
	}{
		tis,
		imports,
	}

	var buf bytes.Buffer
	if err := codeTemplate.Execute(&buf, &data); err != nil {
		log.Fatal(err)
	}
	code, err := format.Source(buf.Bytes())
	if err != nil {
		for i, p := range bytes.Split(buf.Bytes(), []byte("\n")) {
			fmt.Fprintf(os.Stderr, "%d: %s\n", i+1, p)
		}
		log.Fatalf("error formating source: %v", err)
	}

	if *output != "" {
		err = ioutil.WriteFile(*output, code, 0666)
		if err != nil {
			log.Fatal(err)
		}
		return
	}

	os.Stdout.Write(code)
}
