//+build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"reflect"
	"sort"
	"strings"
	"text/template"

	"github.com/seaptc/server/data"
)

var protoValues = []interface{}{
	(*data.AppConfig)(nil),
	(*data.Class)(nil),
	(*data.Conference)(nil),
	(*data.Participant)(nil),
}

type fieldNames struct {
	Go        string
	Firestore string
}

type typeInfo struct {
	Name      string
	FieldSets map[string][]fieldNames
	Fields    []fieldNames
}

func sortNames(names []fieldNames) {
	sort.Slice(names, func(i, j int) bool { return names[i].Go < names[j].Go })
}

func getTypeInfo(t reflect.Type) *typeInfo {
	result := typeInfo{
		Name:      t.Name(),
		FieldSets: make(map[string][]fieldNames),
	}

	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)

		if f.PkgPath != "" && !f.Anonymous {
			continue
		}

		// Find name
		name := f.Name
		if t := f.Tag.Get("firestore"); t != "" {
			t = strings.Split(t, ",")[0]
			if t == "-" {
				continue
			}
			if t != "" {
				name = t
			}
		}

		names := fieldNames{Go: f.Name, Firestore: name}

		result.Fields = append(result.Fields, names)
		if t := f.Tag.Get("fields"); t != "" {
			for _, set := range strings.Split(t, ",") {
				result.FieldSets[set] = append(result.FieldSets[set], names)
			}
		}
	}

	sortNames(result.Fields)
	for _, names := range result.FieldSets {
		sortNames(names)
	}

	return &result
}

var codeTemplate = template.Must(template.New("").Parse(`
// Code generated by gogen.go; DO NOT EDIT.

package data

{{range $type := .}}
const (
    {{range $type.Fields -}}
    {{$type.Name}}_{{.Go}} = {{printf "%q" .Firestore}}
    {{end}}
)
{{end}}

{{range $type := .}}{{range $name, $fields := $type.FieldSets}}
    func (x *{{$type.Name}}) {{$name}}Fields() map[string]interface{} {
        return map[string]interface{}{
            {{range $fields -}}
                {{printf "%q" .Firestore}}: x.{{.Go}},
            {{end -}}
        }
    }
    {{end}}
{{end}}
`))

func main() {
	log.SetFlags(0)
	file := flag.String("output", "", "Write code to `file`")
	flag.Parse()

	var types []*typeInfo
	for _, v := range protoValues {
		t := reflect.TypeOf(v).Elem()
		types = append(types, getTypeInfo(t))
	}
	var buf bytes.Buffer
	if err := codeTemplate.Execute(&buf, types); err != nil {
		log.Fatal(err)
	}
	out, err := format.Source(buf.Bytes())
	if err != nil {
		for i, p := range bytes.Split(buf.Bytes(), []byte("\n")) {
			fmt.Fprintf(os.Stderr, "%d: %s\n", i+1, p)
		}
		log.Fatalf("error formating source: %v", err)
	}

	if *file != "" {
		err = ioutil.WriteFile(*file, out, 0666)
		if err != nil {
			log.Fatal(err)
		}
		return
	}

	os.Stdout.Write(out)

}
